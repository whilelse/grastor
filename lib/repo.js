// Generated by LiveScript 1.4.0
(function(){
  var prelude, find, each, map, filter, reject, empty, Obj, Repo, Node, Ref, rmRef, insRef, Exporter, RawExporter, objFilter, objEach, rmItem, buildObjWithKeys, toArray, isArray, _prt, objectSize;
  prelude = require('prelude-ls');
  find = prelude.find, each = prelude.each, map = prelude.map, filter = prelude.filter, reject = prelude.reject, empty = prelude.empty, Obj = prelude.Obj;
  module.exports = Repo = (function(){
    Repo.displayName = 'Repo';
    var prototype = Repo.prototype, constructor = Repo;
    function Repo(){
      this.nodes = {};
      this.refs = {};
    }
    prototype.inspect = function(){
      return "Repo<" + objectSize(this.nodes) + ">";
    };
    prototype.processWireCmd = function(arg$){
      var ctyp, ref$, ni, ri, nti, rti, sni, gni, name, attrs, ati, bri, val, ref, source, target, beforeRef, node, parentRef, ref1$;
      ctyp = arg$[0], ref$ = arg$[1], ni = ref$.ni, ri = ref$.ri, nti = ref$.nti, rti = ref$.rti, sni = ref$.sni, gni = ref$.gni, name = ref$.name, attrs = ref$.attrs, ati = ref$.ati, bri = ref$.bri, val = ref$.val;
      switch (ctyp) {
      case 'core':
        return this.nodes[ni] = new Node({
          repo: this,
          ni: ni,
          nti: nti,
          name: name,
          attrs: attrs
        });
      case 'comp':
        this.nodes[ni] = new Node({
          repo: this,
          ni: ni,
          nti: nti,
          name: name,
          attrs: attrs
        });
        gni = ni;
        this.refs[ri] = ref = new Ref({
          repo: this,
          ri: ri,
          rti: rti,
          sni: sni,
          gni: gni,
          dep: true
        });
        source = this.nodes[sni] || (function(){
          throw "node " + sni + " not found";
        }());
        target = this.nodes[gni] || (function(){
          throw "node " + gni + " not found";
        }());
        beforeRef = bri ? this.refs[bri] || (function(){
          throw "ref " + bri + " not found";
        }()) : void 8;
        insRef(source.refs, ref, beforeRef);
        return target.inrefs.push(ref);
      case 'link':
        this.refs[ri] = ref = new Ref({
          repo: this,
          ri: ri,
          rti: rti,
          sni: sni,
          gni: gni,
          dep: false
        });
        source = this.nodes[sni] || (function(){
          throw "node " + sni + " not found";
        }());
        target = this.nodes[gni] || (function(){
          throw "node " + gni + " not found";
        }());
        beforeRef = bri ? this.refs[bri] || (function(){
          throw "ref " + bri + " not found";
        }()) : void 8;
        insRef(source.refs, ref, beforeRef);
        return target.inrefs.push(ref);
      case 'move':
        node = this.nodes[ni];
        ref = node.parentRef();
        ref.source().rmRef(ref);
        ref.sni = sni;
        ref.rti = rti;
        return this.nodes[sni].addRef(ref, {
          bri: bri
        });
      case 'name':
        return this.nodes[ni].name = name;
      case 'ntyp':
        node = this.nodes[ni] || (function(){
          throw "node " + ni + " not found";
        }());
        return node.nti = nti;
      case 'attr':
        if (ati === '5') {
          return this.nodes[ni].name = name;
        } else {
          return this.nodes[ni].attrs[ati] = val;
        }
        break;
      case 'rtyp':
        ref = this.refs[ri] || (function(){
          throw "ref " + ri + " not found";
        }());
        return ref.rti = rti;
      case 'del':
        parentRef = this.nodes[ni].parentRef();
        parentRef.source().rmRef(parentRef);
        return ref1$ = (ref$ = this.nodes)[ni], delete ref$[ni], ref1$;
      case 'ulnk':
        ref = this.refs[ri];
        ref.source().rmRef(ref);
        return ref.target().rmInref(ref);
      case 'root':
        return this.root = ni;
      }
    };
    prototype.exportWireCmds = function(cb){
      var e;
      e = new Exporter(this, cb);
      return e['export']();
    };
    prototype.exportRepo = function(){
      var e;
      e = new RawExporter(this);
      return e['export']();
    };
    return Repo;
  }());
  Node = (function(){
    Node.displayName = 'Node';
    var prototype = Node.prototype, constructor = Node;
    function Node(arg$){
      this.repo = arg$.repo, this.ni = arg$.ni, this.nti = arg$.nti, this.name = arg$.name, this.attrs = arg$.attrs;
      this.attrs == null && (this.attrs = {});
      this.refs = [];
      this.inrefs = [];
    }
    prototype.type = function(){
      return this.repo.nodes[this.nti];
    };
    prototype.parentRef = function(){
      return find(function(ref){
        return ref.dep;
      })(
      this.inrefs);
    };
    prototype.parent = function(){
      var r;
      return (r = this.parentRef()) && r.source();
    };
    prototype.addRef = function(ref, arg$){
      var bri, beforeRef;
      bri = arg$.bri;
      beforeRef = bri ? this.repo.refs[bri] || (function(){
        throw "bri not found";
      }()) : void 8;
      return insRef(this.refs, ref, beforeRef);
    };
    prototype.rmRef = function(ref){
      return rmRef(this.refs, ref);
    };
    prototype.rmInref = function(ref){
      return rmRef(this.inrefs, ref);
    };
    return Node;
  }());
  Ref = (function(){
    Ref.displayName = 'Ref';
    var prototype = Ref.prototype, constructor = Ref;
    function Ref(arg$){
      this.repo = arg$.repo, this.ri = arg$.ri, this.rti = arg$.rti, this.sni = arg$.sni, this.gni = arg$.gni, this.dep = arg$.dep;
    }
    prototype.inspect = function(){
      return JSON.stringify([this.ri, this.rti, this.sni, this.gni, this.dep]);
    };
    prototype.source = function(){
      return this.repo.nodes[this.sni] || (function(){
        throw "@sni not found in " + this.inspect();
      }.call(this));
    };
    prototype.target = function(){
      return this.repo.nodes[this.gni] || (function(){
        throw "@gni not found in " + this.inspect();
      }.call(this));
    };
    prototype.type = function(){
      return this.repo.nodes[this.rti] || (function(){
        throw "@rti not found in " + this.inspect();
      }.call(this));
    };
    return Ref;
  }());
  rmRef = function(list, ref){
    var index;
    if ((index = list.indexOf(ref)) !== -1) {
      return list.splice(index, 1);
    } else {
      throw "Could not find ref in list";
    }
  };
  insRef = function(list, ref, beforeRef){
    var index;
    if (beforeRef) {
      index = list.indexOf(beforeRef);
      if (index === -1) {
        console.log("list", list);
        console.log("ref", ref);
        console.log("before-ref", beforeRef);
        throw "before-ref not found in list";
      }
      return list.splice(index, 0, ref);
    } else {
      return list.push(ref);
    }
  };
  Exporter = (function(){
    Exporter.displayName = 'Exporter';
    var prototype = Exporter.prototype, constructor = Exporter;
    function Exporter(repo, commandCallback){
      this.repo = repo;
      this.commandCallback = commandCallback;
      this.queue = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '112'];
      this.known = buildObjWithKeys(this.queue, true);
      this.ignored = {};
      this.dumped = {};
      this.lastFuncId = -1;
      this.funcs = [];
      this.dependencies = {};
      this.dependants = {};
      this.riOrder = {};
    }
    prototype['export'] = function(){
      var ni, results$ = [];
      while (ni = this.queue.shift()) {
        if (this.limit && this.dumped.size >= this.limit) {
          break;
        }
        results$.push(this.migrateNode(ni));
      }
      return results$;
    };
    prototype.exportCommand = function(cmd, args){
      return this.commandCallback([cmd, args]);
    };
    prototype.migrateNode = function(ni){
      var node, nti, name, attrs, pr, dumpableAttrs, ati, val, ri, sni, rti, refs, i$, len$, ref, this$ = this, results$ = [];
      if (this.limit && this.dumped.size >= this.limit) {
        return;
      }
      if (this.dumped[ni]) {
        return;
      }
      if (ni === '947' || ni === '126' || ni === '122') {
        return;
      }
      node = this.repo.nodes[ni] || (function(){
        throw "node not found " + ni;
      }());
      nti = node.nti, name = node.name, attrs = node.attrs;
      if (nti === ni || this.dumped[nti]) {
        pr = node.parentRef();
        dumpableAttrs = {};
        if (pr && this.dumped[pr.sni] && this.dumped[pr.rti]) {
          for (ati in attrs) {
            val = attrs[ati];
            if (this.dumped[ati]) {
              dumpableAttrs[ati] = val;
            } else {
              this.dependsOn(ati, {
                ni: ni,
                ati: ati,
                val: val
              }, fn$);
            }
          }
          ri = pr.ri, sni = pr.sni, rti = pr.rti;
          this.exportCommand('comp', {
            ri: ri,
            sni: sni,
            rti: rti,
            bri: this.trackAndFindBri(sni, ri),
            ni: ni,
            nti: nti,
            name: name,
            attrs: dumpableAttrs
          });
        } else {
          this.exportCommand('core', {
            ni: ni,
            nti: nti,
            name: name
          });
          for (ati in attrs) {
            val = attrs[ati];
            this.dependsOn(ati, {
              ni: ni,
              ati: ati,
              val: val
            }, fn1$);
          }
          if (pr) {
            this.dependsOn(pr.sni, {
              pr: pr,
              ni: ni,
              name: name,
              dumpableAttrs: dumpableAttrs
            }, function(arg$){
              var pr, ni, name, dumpableAttrs;
              pr = arg$.pr, ni = arg$.ni, name = arg$.name, dumpableAttrs = arg$.dumpableAttrs;
              return this$.dependsOn(pr.rti, {
                pr: pr,
                ni: ni,
                name: name,
                dumpableAttrs: dumpableAttrs
              }, function(arg$){
                var pr, ni, name, dumpableAttrs, ri, sni, rti;
                pr = arg$.pr, ni = arg$.ni, name = arg$.name, dumpableAttrs = arg$.dumpableAttrs;
                ri = pr.ri, sni = pr.sni, rti = pr.rti;
                return this$.exportCommand('comp', {
                  ri: ri,
                  sni: sni,
                  rti: rti,
                  bri: this$.trackAndFindBri(sni, ri),
                  ni: ni,
                  nti: nti,
                  name: name,
                  attrs: dumpableAttrs
                });
              });
            });
          }
        }
        rmItem(ni, this.queue);
        this.dumped[ni] = true;
        this.resolveDependency(ni);
        if (refs = node.refs) {
          for (i$ = 0, len$ = refs.length; i$ < len$; ++i$) {
            ref = refs[i$];
            results$.push(this.dependsOn(ref.rti, {
              ref: ref
            }, fn2$));
          }
          return results$;
        }
      } else {
        return this.dependsOn(nti, {
          ni: ni
        }, function(arg$){
          var ni;
          ni = arg$.ni;
          return this$.migrateNode(ni);
        });
      }
      function fn$(arg$){
        var ni, ati, val;
        ni = arg$.ni, ati = arg$.ati, val = arg$.val;
        return this$.exportCommand('attr', {
          ni: ni,
          ati: ati,
          val: val
        });
      }
      function fn1$(arg$){
        var ni, ati, val;
        ni = arg$.ni, ati = arg$.ati, val = arg$.val;
        return this$.exportCommand('attr', {
          ni: ni,
          ati: ati,
          val: val
        });
      }
      function fn2$(arg$){
        var ref;
        ref = arg$.ref;
        if (ref.dep) {
          return this$.migrateNode(ref.gni);
        } else {
          return this$.dependsOn(ref.gni, {
            ref: ref
          }, function(arg$){
            var ref, ri, sni, rti, gni, dep;
            ref = arg$.ref;
            ri = ref.ri, sni = ref.sni, rti = ref.rti, gni = ref.gni, dep = ref.dep;
            return this$.exportCommand('link', {
              ri: ri,
              sni: sni,
              rti: rti,
              gni: gni,
              bri: this$.trackAndFindBri(sni, ri)
            });
          });
        }
      }
    };
    prototype.discover = function(ni){
      if (!(this.known[ni] || this.ignored[ni])) {
        this.queue.push(ni);
        return this.known[ni] = true;
      }
    };
    prototype.dependsOn = function(niList, arg, func){
      var funcId, i$, len$, ni, ref$, this$ = this, results$ = [];
      niList = reject(function(ni){
        return this$.dumped[ni];
      })(
      toArray(niList));
      if (empty(
      niList)) {
        return func(arg);
      } else {
        funcId = this.lastFuncId += 1;
        this.funcs[funcId] = function(){
          return func(arg);
        };
        this.dependencies[funcId] = niList;
        for (i$ = 0, len$ = niList.length; i$ < len$; ++i$) {
          ni = niList[i$];
          (ref$ = this.dependants)[ni] == null && (ref$[ni] = []);
          this.dependants[ni].push(funcId);
          results$.push(this.discover(ni));
        }
        return results$;
      }
    };
    prototype.resolveDependency = function(ni){
      var funcIds, i$, len$, funcId, func, ref$, ref1$;
      funcIds = this.dependants[ni];
      if (funcIds && funcIds.length > 0) {
        for (i$ = 0, len$ = funcIds.length; i$ < len$; ++i$) {
          funcId = funcIds[i$];
          rmItem(ni, this.dependencies[funcId]);
          if (this.dependencies[funcId].length === 0) {
            delete this.dependencies[funcId];
            func = this.funcs[funcId];
            delete this.funcs[funcId];
            func();
          }
        }
      }
      return ref1$ = (ref$ = this.dependants)[ni], delete ref$[ni], ref1$;
    };
    prototype.trackAndFindBri = function(ni, ri){
      var riList, ref$, orig, curr, index, candidates, bri, briIndex;
      riList = map(function(it){
        return it.ri;
      })(
      this.repo.nodes[ni].refs);
      (ref$ = this.riOrder)[ni] == null && (ref$[ni] = [riList, []]);
      ref$ = this.riOrder[ni], orig = ref$[0], curr = ref$[1];
      if (curr.indexOf(ri) !== -1) {
        throw "ri already exported. ni:" + ni + ", ri:" + ri + ", ri-list:" + riList + ", orig: " + orig + ", curr: " + curr;
      }
      index = orig.indexOf(ri);
      if (index === -1) {
        throw "ri node found in orig: " + ri + " - " + orig + " (ni: " + ni + ")";
      }
      candidates = orig.slice(index + 1);
      bri = find(function(cand){
        return curr.indexOf(cand) !== -1;
      })(
      candidates);
      if (bri) {
        briIndex = curr.indexOf(bri);
        if (briIndex === -1) {
          throw "bri not found in curr: " + bri + " - " + curr;
        }
        curr.splice(briIndex, 0, ri);
      } else {
        curr.push(ri);
      }
      return bri;
    };
    return Exporter;
  }());
  RawExporter = (function(){
    RawExporter.displayName = 'RawExporter';
    var prototype = RawExporter.prototype, constructor = RawExporter;
    function RawExporter(repo){
      this.repo = repo;
    }
    prototype['export'] = function(){
      var data, ni, ref$, node, nti, name, attrs, refs, inrefs, ri, ref, rti, sni, gni, dep;
      data = {
        root: this.repo.root,
        nodes: {},
        refs: {}
      };
      for (ni in ref$ = this.repo.nodes) {
        node = ref$[ni];
        nti = node.nti, name = node.name, attrs = node.attrs;
        refs = map(fn$)(
        node.refs);
        inrefs = map(fn1$)(
        node.inrefs);
        data.nodes[ni] = {
          ni: ni,
          nti: nti,
          name: name,
          attrs: attrs,
          refs: refs,
          inrefs: inrefs
        };
      }
      for (ri in ref$ = this.repo.refs) {
        ref = ref$[ri];
        rti = ref.rti, sni = ref.sni, gni = ref.gni, dep = ref.dep;
        data.refs[ri] = {
          ri: ri,
          rti: rti,
          sni: sni,
          gni: gni,
          dep: dep
        };
      }
      return data;
      function fn$(r){
        return r.ri;
      }
      function fn1$(r){
        return r.ri;
      }
    };
    return RawExporter;
  }());
  objFilter = function(cb, obj){
    var newObj, key, val;
    newObj = {};
    for (key in obj) {
      val = obj[key];
      if (cb(key, val)) {
        newObj[key] = val;
      }
    }
    return newObj;
  };
  objEach = function(cb, obj){
    var key, val, results$ = [];
    for (key in obj) {
      val = obj[key];
      results$.push(cb(key, val));
    }
    return results$;
  };
  rmItem = function(x, arr){
    var index;
    index = arr.indexOf(x);
    if (index !== -1) {
      arr.splice(index, 1);
    }
    return arr;
  };
  buildObjWithKeys = function(keys, value){
    var obj, i$, len$, key;
    obj = {};
    for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
      key = keys[i$];
      obj[key] = value;
    }
    return obj;
  };
  toArray = function(x){
    if (isArray(x)) {
      return x;
    } else {
      return [x];
    }
  };
  isArray = function(x){
    return deepEq$(_prt(x), '[object Array]', '===');
  };
  _prt = function(x){
    return Object.prototype.toString.call(x);
  };
  objectSize = function(obj){
    var size, key, value;
    size = 0;
    for (key in obj) {
      value = obj[key];
      if (obj.hasOwnProperty(key)) {
        size += 1;
      }
    }
    return size;
  };
  function deepEq$(x, y, type){
    var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
        has = function (obj, key) { return hasOwnProperty.call(obj, key); };
    var first = true;
    return eq(x, y, []);
    function eq(a, b, stack) {
      var className, length, size, result, alength, blength, r, key, ref, sizeB;
      if (a == null || b == null) { return a === b; }
      if (a.__placeholder__ || b.__placeholder__) { return true; }
      if (a === b) { return a !== 0 || 1 / a == 1 / b; }
      className = toString.call(a);
      if (toString.call(b) != className) { return false; }
      switch (className) {
        case '[object String]': return a == String(b);
        case '[object Number]':
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          return +a == +b;
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') { return false; }
      length = stack.length;
      while (length--) { if (stack[length] == a) { return true; } }
      stack.push(a);
      size = 0;
      result = true;
      if (className == '[object Array]') {
        alength = a.length;
        blength = b.length;
        if (first) {
          switch (type) {
          case '===': result = alength === blength; break;
          case '<==': result = alength <= blength; break;
          case '<<=': result = alength < blength; break;
          }
          size = alength;
          first = false;
        } else {
          result = alength === blength;
          size = alength;
        }
        if (result) {
          while (size--) {
            if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
          }
        }
      } else {
        if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
          return false;
        }
        for (key in a) {
          if (has(a, key)) {
            size++;
            if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
          }
        }
        if (result) {
          sizeB = 0;
          for (key in b) {
            if (has(b, key)) { ++sizeB; }
          }
          if (first) {
            if (type === '<<=') {
              result = size < sizeB;
            } else if (type === '<==') {
              result = size <= sizeB
            } else {
              result = size === sizeB;
            }
          } else {
            first = false;
            result = size === sizeB;
          }
        }
      }
      stack.pop();
      return result;
    }
  }
}).call(this);
